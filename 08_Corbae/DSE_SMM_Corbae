############################################################################################################
# Simulated Method of Moments 
# DSE Summer School 2024
# Professor: Dean Corbae
############################################################################################################

# Packages
using Parameters, Distributions, Random, LinearAlgebra, Optim, Interpolations, LaTeXStrings

# Simulation of "true data"
# Draw shocks
function shock(T::Int64, H::Int64; seed = missing)
    if !ismissing(seed)
        Random.seed!(seed)
    end
    rand(Normal(0,1),T,H)
end

# AR(1) process
function ar(Îµ::Array{Float64,2},Ï::Float64,Ïƒ::Float64)
    T = size(Îµ)[1]  # Observations
    H = size(Îµ)[2]  # Number of simulations

    # Initialize vector
    x = zeros(T, H)
    # Fill vector of AR(1) process given parameters Ïâ‚€ and Ïƒâ‚€
    for i_H = 1:H
        x[1,i_H] = Îµ[1,i_H]
        for i = 2:T
            x[i,i_H]=##########################
        end
    end
    x
end

# Compute asymptotic moments
function asy_m(x::Array{Float64,2})
    T = size(x)[1]
    H = size(x)[2]
    # Mean
    xÌ„ = repeat(sum(x;dims=1)./T,T)
    # Lag
    xâ‚‹ = vcat(zeros(H)',x[1:T-1,:])
    # Vector of moments mâ‚ƒ(b)
    asy_m = zeros(T,H,3)
    asy_m[:,:,1] = ################
    asy_m[:,:,2] = ################
    asy_m[:,:,3] = ################

    asy_m
end

# Compute sample moments
function m(asy_m::Array{Float64,3})
    T = size(asy_m)[1]
    H = size(asy_m)[2]
    m = reshape(sum(asy_m; dims=1:2)/(T*H),3)
end

# Structure for parameters
@with_kw struct Primitives
    T::Int64    = 200   # Number of periods
    H::Int64    = 10    # Number of simulation
    LÊ²::Int64   = 4     # Number of lags
    nd::Float64   = 1e-10 # Numerical derivative
    Ï_g::Array{Float64,1} = 0.35:0.01:0.65
    Ïƒ_g::Array{Float64,1} = 0.80:0.01:1.20
end

# Structure for initial conditions
mutable struct DGP
    Ïâ‚€::Float64
    Ïƒâ‚€::Float64
    Îµ::Array{Float64,2}
    xâ‚€::Array{Float64,2}
    asy_mâ‚€::Array{Float64,3}
    M_T::Array{Float64,1}
end

# Structure for estimation
mutable struct Estimation
    moments::Array{Int64,1}       # moments for objective function
    e::Array{Float64,2}             # shocks simulated
    ÏÌ‚â‚::Float64                     # first-stage estimator for Ï
    ÏƒÌ‚â‚::Float64                     # first-stage estimator for Ïƒ
    ÏÌ‚â‚›Â¹::Float64                     # first-stage s.e. for Ï
    ÏƒÌ‚â‚›Â¹::Float64                     # first-stage s.e. for Ïƒ
    ğ½â‚::Array{Float64,2}             # first-stage Jacobian matrix
    ğ•::Array{Float64,2}             # estimator for optimal weighting matrix
    ÏÌ‚â‚‚::Float64                     # second-stage estimator for Ï
    ÏƒÌ‚â‚‚::Float64                     # second-stage estimator for Ïƒ
    ÏÌ‚â‚›Â²::Float64                    # second-stage s.e. for Ï
    ÏƒÌ‚â‚›Â²::Float64                    # second-stage s.e. for Ïƒ
    ğ½â‚‚::Array{Float64,2}            # first-stage Jacobian matrix
    ğ‰::Float64                      # Sargan J-test statistic
    p_value_ğ‰::Float64              # p-value for Sargan test
end

# Simulation
function Initialize_True_Data(; seed = missing)
    Ïâ‚€ = 0.5
    Ïƒâ‚€ = 1.0
    Îµ = shock(200,1; seed = seed)
    xâ‚€ = ar(Îµ,Ïâ‚€,Ïƒâ‚€)
    mâ‚€ = asy_m(xâ‚€)
    M_T = m(mâ‚€)

    DGP(Ïâ‚€,Ïƒâ‚€,Îµ,xâ‚€,mâ‚€,M_T)
end

function Initialize_Estimation(moments; seed = missing)
    @unpack T, H = Primitives()
    e = shock(T,H; seed = seed)
    ÏÌ‚â‚ = 0
    ÏƒÌ‚â‚ = 0
    ÏÌ‚â‚›Â¹ = 0
    ÏƒÌ‚â‚›Â¹ = 0
    ğ½â‚ = zeros(2,2)
    ğ• = zeros(length(moments),length(moments))
    ÏÌ‚â‚‚ = 0
    ÏƒÌ‚â‚‚ = 0
    ÏÌ‚â‚›Â² = 0
    ÏƒÌ‚â‚›Â² = 0
    ğ½â‚‚ = zeros(2,2)
    ğ‰ = 0
    p_value_ğ‰ = 0

    Estimation(moments, e, ÏÌ‚â‚, ÏƒÌ‚â‚, ÏÌ‚â‚›Â¹, ÏƒÌ‚â‚›Â¹, ğ½â‚, ğ•, ÏÌ‚â‚‚, ÏƒÌ‚â‚‚, ÏÌ‚â‚›Â², ÏƒÌ‚â‚›Â², ğ½â‚‚, ğ‰, p_value_ğ‰)
end

# Compute objective function
function J_TH(b, e, moments, W, M_T)
    Ï = b[1]
    Ïƒ = b[2]

    M_TH = m(asy_m(ar(e, Ï, Ïƒ)))
    ################
end

# 3D plots
function plot_3d_J_TH(R::Estimation, D::DGP, stage::Int64)
    @unpack Ï_g, Ïƒ_g = Primitives()

    if stage == 1
        W = I
        title = string("First-Stage Objective Function: ", join(string.("asy_m",R.moments," ")))
    elseif stage == 2
        W = R.ğ•
        title = string("Second-Stage Objective Function: ", join(string.("asy_m",R.moments," ")))
    else
        error("Specify valid stage arg.")
    end

    function J_TH_plot(Ï,Ïƒ)
        return J_TH([Ï,Ïƒ], R.e, R.moments, W, D.M_T)
    end

    surface(Ï_g,Ïƒ_g, J_TH_plot,opacity=0.7,c = :blues);
    xlabel!(L"Ï");
    ylabel!(L"Ïƒ");
end

# Coefficient estimation
function bÌ‚(R::Estimation, D::DGP, stage::Int64)
    if stage == 1
        W = I
    elseif stage == 2
        W = R.ğ•
    else
        error("Specify valid stage arg")
    end

    opt = optimize(b->J_TH(b, R.e, R.moments, W, D.M_T), [D.Ïâ‚€,D.Ïƒâ‚€])
    Optim.minimizer(opt)
end

# Estimation of optimal weighting matrix ğ•
function ğ•(R::Estimation)
    @unpack T, H, LÊ² = Primitives()

    asy_m_1 = asy_m(ar(R.e, R.ÏÌ‚â‚, R.ÏƒÌ‚â‚))
    M_TH_1 = m(asy_m_1)

    function compute_Î“(j)
        Î“ = zeros(3,3)
        for i_1 = 1:3
            for i_2 in 1:3
                Î“[i_1,i_2]=################
            end
        end
        Î“[R.moments, R.moments]
    end
    S_TH = compute_Î“(0)
    for j = 1:LÊ²
        Î“_j = compute_Î“(j)
        S_TH += ################
    end
    S_TH = ################
    inv(S_TH)
end

# Computation of numerical derivative
function jacobian(R::Estimation, stage::Int64)
    @unpack nd = Primitives()

    # choose weighting matrix based on stage argument
    if stage == 1
        Ï = R.ÏÌ‚â‚
        Ïƒ = R.ÏƒÌ‚â‚

    elseif stage == 2
        Ï = R.ÏÌ‚â‚‚
        Ïƒ = R.ÏƒÌ‚â‚‚
    else
        error("Specify valid stage arg.")
    end

    M_TH   = m(asy_m(ar(R.e, Ï, Ïƒ)))
    M_TH_Ï = m(asy_m(ar(R.e, Ï - nd, Ïƒ)))
    M_TH_Ïƒ = m(asy_m(ar(R.e, Ï, Ïƒ - nd)))

    jacobian_Ï = ################
    jacobian_Ïƒ = ################

    return(hcat(jacobian_Ï[R.moments], jacobian_Ïƒ[R.moments]))
end

# Computation of S.E.
function se(R::Estimation, stage::Int64)
    @unpack T = Primitives()
    if stage == 1
        W = I
        jacobian = R.ğ½â‚
    elseif stage == 2
        W = R.ğ•
        jacobian = R.ğ½â‚‚
    else
        error("Specify valid stage arg.")
    end
    ################
end

# Computation of Sargan ğ‰ statistic
function j_test(R::Estimation, D::DGP)
    @unpack T, H = Primitives()

    stat = ################
    p_value = cdf(Chisq(1), stat)

    return [stat, p_value]
end

# Estimation
function estimate(moments; D_seed = missing, R_seed = missing)
    # Initialize results objects
    D = Initialize_True_Data(;seed = D_seed)
    R = Initialize_Estimation(moments; seed = R_seed)

    # First-stage estimation
    bÌ‚â‚   = bÌ‚(R, D, 1)
    R.ÏÌ‚â‚ = bÌ‚â‚[1]
    R.ÏƒÌ‚â‚ = bÌ‚â‚[2]

    # S.E. computation
    R.ğ½â‚ = jacobian(R, 1)
    R.ÏÌ‚â‚›Â¹   = se(R, 1)[1]
    R.ÏƒÌ‚â‚›Â¹   = se(R, 1)[2]

    # Estimate optimal weighting matrix ğ•
    R.ğ• = ğ•(R)

    # Second-stage estimation
    bÌ‚â‚‚   = bÌ‚(R, D, 2)
    R.ÏÌ‚â‚‚ = bÌ‚â‚‚[1]
    R.ÏƒÌ‚â‚‚ = bÌ‚â‚‚[2]

    # S.E. computation
    R.ğ½â‚‚ = jacobian(R, 2)
    R.ÏÌ‚â‚›Â²   = se(R, 2)[1]
    R.ÏƒÌ‚â‚›Â²   = se(R, 2)[2]

    # ğ‰ test
    R.ğ‰   = j_test(R, D)[1]
    R.p_value_ğ‰ = j_test(R, D)[2]

    R
end

# Bootstrap
function bootstrap_se(moments)
    n_bs = 1000

    bs_results = zeros(n_bs, 4)
    for i = 1:n_bs
        println(i)

        # Initialize results objects
        D = Initialize_True_Data()
        R = Initialize_Estimation(moments)

        # First stage
        bÌ‚â‚   = bÌ‚(R, D, 1)
        R.ÏÌ‚â‚ = bÌ‚â‚[1]
        R.ÏƒÌ‚â‚ = bÌ‚â‚[2]

        # Estimate optimal weighting matrix
        R.ğ• = ğ•(R)

        # second stage
        bÌ‚â‚‚   = bÌ‚(R, D, 2)

        bs_results[i, 1] = bÌ‚â‚[1]
        bs_results[i, 2] = bÌ‚â‚‚[1]
        bs_results[i, 3] = bÌ‚â‚[2]
        bs_results[i, 4] = bÌ‚â‚‚[2]
    end
    bs_results
end

# Report estimates in Table
function process_results(R::Estimation)
    [R.ÏÌ‚â‚, R.ÏÌ‚â‚›Â¹, R.ÏƒÌ‚â‚, R.ÏƒÌ‚â‚›Â¹, R.ÏÌ‚â‚‚, R.ÏÌ‚â‚›Â², R.ÏƒÌ‚â‚‚, R.ÏƒÌ‚â‚›Â², R.ğ‰, R.p_value_ğ‰]
end

function create_table(results_vector::Array{Estimation})

    # create matrix of results
    temp = reduce(hcat,process_results.(results_vector))'

    # convert into data frame
    table = DataFrame(Tables.table(temp))
    rename!(table, [:rho_hat_1, :rho_se_1, :sigma_hat_1, :sigma_se_1, :rho_hat_2, :rho_se_2, :sigma_hat_2, :sigma_se_2, :j_test_stat, :j_test_p_value])
end
